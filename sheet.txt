1-bit full adder using behavioural 

module FullAdder(
input A, B, Cin,
output reg S, Cout
);
always @* begin
case ({A, B, Cin})
3'b000: begin
S = 0;
Cout = 0;
end
3'b001: begin
S = 1;
Cout = 0;
end
3'b010: begin
S = 1;
Cout = 0;
end
3'b011: begin
S = 0;
Cout = 1;
end
3'b100: begin
S = 1;
Cout = 0;
end
3'b101: begin
S = 0;
Cout = 1;
end
3'b110: begin
S = 0;
Cout = 1;
end
3'b111: begin
S = 1;
Cout = 1;
end
endcase
end
endmodule

16-bit adder using structural modelling

module FullAdder16 (
input [15:0] a,
input [15:0] b,
input c_n,
output [15:0] s,
output cout
);
wire [14:0] c;
FullAdder FullAdder1 (a[0], b[0], c_n, s[0], c[0]);
FullAdder FullAdder2 (a[1], b[1], c[0], s[1], c[1]);
FullAdder FullAdder3 (a[2], b[2], c[1], s[2], c[2]);
FullAdder FullAdder4 (a[3], b[3], c[2], s[3], c[3]);
FullAdder FullAdder5 (a[4], b[4], c[3], s[4], c[4]);
FullAdder FullAdder6 (a[5], b[5], c[4], s[5], c[5]);
FullAdder FullAdder7 (a[6], b[6], c[5], s[6], c[6]);
FullAdder FullAdder8 (a[7], b[7], c[6], s[7], c[7]);
FullAdder FullAdder9 (a[8], b[8], c[7], s[8], c[8]);
FullAdder FullAdder10 (a[9], b[9], c[8], s[9], c[9]);
FullAdder FullAdder11 (a[10], b[10], c[9], s[10], c[10]);
FullAdder FullAdder12 (a[11], b[11], c[10], s[11], c[11]);
FullAdder FullAdder13 (a[12], b[12], c[11], s[12], c[12]);
FullAdder FullAdder14 (a[13], b[13], c[12], s[13], c[13]);
FullAdder FullAdder15 (a[14], b[14], c[13], s[14], c[14]);
FullAdder FullAdder16 (a[15], b[15], c[14], s[15], cout);
endmodule
module FullAdder (
input A,
input B,
input C_n,
output S,
output Cout
);
assign S = A ^ B ^ C_n;
assign Cout = (A & C_n) | (B & C_n) | (A & B);
endmodule

binary adder and subtractor using Twoâ€™s Compliment 

module TwoCompAdder (
input [3:0] A,
input [3:0] B,
output [3:0] Sum,
output Cout
);
wire [2:0] C;
assign EN = 1;
wire [3:0] outt;
assign outt[0] = B[0] ^ EN;
assign outt[1] = B[1] ^ EN;
assign outt[2] = B[2] ^ EN;
assign outt[3] = B[3] ^ EN;
FullAdder FullAdder0 (A[0], outt[0], EN, Sum[0], C[0]);
FullAdder FullAdder1 (A[1], outt[1], C[0], Sum[1], C[1]);
FullAdder FullAdder2 (A[2], outt[2], C[1], Sum[2], C[2]);
FullAdder FullAdder3 (A[3], outt[3], C[2], Sum[3], Cout);
endmodule
module FullAdder (
input a, b, c_n,
output s, cout
);
assign s = a ^ b ^ c_n;
assign cout = (a & c_n) | (b & c_n) | (a & b);
endmodule

16-bit ALU which supports all the arithmetic and shifting operations.

module ALU16 (
input [15:0] A,
input [15:0] B,
input C,
input [2:0] SEL,
output CR,
output reg [31:0] MD,
output reg [15:0] RES
);
always @(*)
begin
case (SEL)
3'b000: RES = A + B + C;
3'b001: RES = A - B;
3'b010: MD = A * B;
3'b011: MD = {A / B , A % B};
3'b100: RES = A & B;
3'b101: RES = A | B;
3'b110: RES = ~A;
3'b111: RES = A ^ B;
default: RES = A;
endcase
end
endmodule

Lab Exercise:
1. Design a 4-bit serial in and serial out shift register using D flip flop
module exp4_exl (
input clk,
input sin,
output reg sout
);
reg d1, d2, d3;
always @(posedge clk) begin
d1 <= sin;
d2 <= d1;
d3 <= d2;
sout <= d3;
end
endmodule
2. Implement a 32-bit shift register having 4 control inputs (load, shift-right, shift-left, parallel-
output)
module exp4_ex2 (
input clk,
input [31:0] in,
input [1:0] sel,
output reg [31:0] out
);
reg [31:0] register;
integer j = 0;
always @(in or sel) begin
case(sel)
2'b00: register = in[31:0];
2'b01: register = {1'b1, in[30:0]};
2'b10: register = {in[30:0], 1'b0};
default: register = 32'b0;
endcase
end
assign out = register;
endmodule

4-bit Synchronous Johnson counter

module exp4_ex3 (
input clk,
input [3:0] sin,
output reg [3:0] s_out
);
integer i;
always @(posedge clk) begin
for (i = 0; i < 8; i = i + 1) begin
s_out = {~sin[0], sin[3:1]};
end
end
endmodule

n-bit ring counter using a D flip flop

module exp4_post1# (
parameter N = 16,
input rst,
input elk,
input [N-1:0] sin,
output reg [N-1:0] sout
);
integer i;
always @(posedge clk) begin
if (rst) begin
sout <= 0;
end
else begin
for (i = 0; i < N; i = i + 1) begin
sout[i] = ~sin[N-1-i];
end
end
end
endmodule

32-bit barrel shifter

module exp4_post2 (
input [31:0] input_data,
input [4:0] shift_amount,
input sel,
output reg [31:0] out
);
always @(*) begin
if (sel) begin // shift right
out = (shift_amount == 0) ? input_data : input_data >> shift_amount;
end
else begin
out = (shift_amount == 0) ? input_data : input_data << shift_amount; //
shift left
end
end
endmodule

4X8 RAM 

module e5 (out, in, addr, RW, CS);
output [7:0] out;
input [7:0] in;
input [1:0] addr;
input RW, CS;
reg [7:0] out;
reg [7:0] mem [3:0];
always @ (negedge CS)
begin
if (RW == 1'b0) // READ
begin
out = mem[addr];
end
else
begin
if (RW == 1'b1) // WRITE
mem[addr] = in;
end
end
endmodule

4X8 PROM

module exp5_eva5 (
input en,
input clk,
input [1:0] addr,
output reg [7:0] data_out
);
reg [7:0] mem [3:0];
initial begin
mem[2'b00] = 8'b10101010;
mem[2'b01] = 8'b01010101;
mem[2'b10] = 8'b00001111;
mem[2'b11] = 8'b11111111;
end
always @(posedge clk) begin
if (en == 1) begin
data_out = mem[addr];
end
end
endmodule

Dual-port RAM  (allows writing at only one port at the positive 
edge the clock. However, the reading is done from both ports asynchronously)

module exp5_eva6 (
input [7:0] data_in,
input clk,
input wr,
input sel,
input [1:0] addr,
output reg [7:0] data_out1,
output reg [7:0] data_out2
);
reg [7:0] mem1 [0:3], mem2 [0:3];
always @(posedge clk) begin
if (wr == 1) begin
data_out1 = mem1[addr];
data_out2 = mem2[addr];
end
else if (wr == 0) begin
if (sel == 0)
mem1[addr] = data_in;
else
mem2[addr] = data_in;
end
end
endmodule

Execution block

module exp7(input [15:0] a,b,bi,data_in ,input [5:0] op_dec,input clk,reset ,output reg [15:0]
ans_ex,data_out,B_Bypass,output [3:0] flag_ex);
parameter N=5;
wire[15:0]ans_temp,data_out_buffer;
assign ans_temp=
op_dec==6'b000000 ? a + b :
op_dec==6'b000001 ? a - b :
op_dec==6'b000010 ? b :
op_dec==6'b000100 ? a & b :
op_dec==6'b000101 ? a | b :
op_dec==6'b000110 ? a^b :
op_dec==6'b000111 ? ~b :
op_dec==6'b001000 ? a + bi :
op_dec==6'b001001 ? a - bi :
op_dec==6'b001010 ? bi :
op_dec==6'b001100 ? a & bi :
op_dec==6'b001101 ? a | bi :
op_dec==6'b001110 ? a ^ bi :
op_dec==6'b001111 ? ~bi :
op_dec==6'b010000 ? ans_ex :
op_dec==6'b010001 ? ans_ex :
op_dec==6'b010100 ? a :
op_dec==6'b010101 ? a :
op_dec==6'b010110 ? data_in :
op_dec==6'b011000 ? ans_ex :
op_dec==6'b011001 ? ans_ex :
op_dec==6'b011001 ? a<<b[3:0] :
op_dec==6'b011010 ? a>>b[3:0]:
op_dec==6'b011011 ? {a[15],a[15:1]} :
op_dec==6'b011100 ? ans_ex :
op_dec==6'b011101 ? ans_ex :
op_dec==6'b011110 ? ans_ex :
op_dec==6'b011111 ? ans_ex :16'b1111111111111111 ;
assign data_out_buffer=data_in;
assign flag_ex[0]=((op_dec == 6'b000000) || (op_dec==6'b000001) || (op_dec==6'b001000) ||
(op_dec==6'b001001))?
ans_ex[15]:1'b0 ; //carry
assign flag_ex[1]=(ans_temp == 16'b0)? 1'b1:1'b0; //zero
assign flag_ex[2]= ((a[15] ^ b[15]==0) && (ans_temp[15] != a[15])) ? 1'b1:1'b0; //overflow
assign flag_ex[3]= (^ans_temp ==0) ? 1'b0:1'b1; //parity
always @(posedge clk or posedge reset)
begin
if(reset)
begin
ans_ex = 0;
B_Bypass = 0;
data_out = 0;
end
else if(clk) begin
ans_ex = ans_temp;
B_Bypass = b;
data_out = (data_out_buffer);
end
end
endmodule
`timescale 1ns / 1ps
module testbench;
// Inputs
reg [15:0] a, b, bi, data_in;
reg [5:0] op_dec;
reg clk, reset;
// Outputs
wire [15:0] ans_ex, data_out,B_Bypass;
wire [3:0] flag_ex;
// Instantiate the module
exp7 dut (
.a(a),
.b(b),
.bi(bi),
.data_in(data_in),
.op_dec(op_dec),
.clk(clk),
.reset(reset),
.ans_ex(ans_ex),
.data_out(data_out),
.B_Bypass(),
.flag_ex(flag_ex)
);
initial begin
a = 16'b1111111000111001;
b = 16'b0000000000000111;
bi = 16'b1111111111111111;
op_dec=6'b000000;
reset = 1;
clk = 0;
#300 $finish;
end
always #256 op_dec[4]=~op_dec[4];
always #128 op_dec[3]=~op_dec[3];
always #64 op_dec[2]=~op_dec[2];
always #32 op_dec[1]=~op_dec[1];
always #16 op_dec[0]=~op_dec[0];
always #8 a=~a;
always #4 b=~b;
always #2 bi=~bi;
always #1 data_in =~ data_in;
always #1 clk =~clk;
always #2 reset=~reset;
endmodule

Control section of single cycle datapath

module exp8(op, fn, regwrite, regdst, reginsrc, alusrc, addsub, logicfn, fnclass, dataread,
datawrite, brtype, pcsrc);
input [5:0]op, fn;
output reg [1:0]regdst, reginsrc, logicfn, fnclass, brtype, pcsrc;
output reg regwrite, alusrc, addsub, dataread, datawrite;
always @(op or fn)
begin
if(op==6'b001111) //load upper immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'bz;
logicfn=1'bz;
fnclass=2'b00;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b001000) //add immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'b0;
logicfn=1'bz;
fnclass=2'b10;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b001010) // set less than immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'b1;
logicfn=1'bz;
fnclass=2'b01;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b001100) //and immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'bz;
logicfn=2'b00;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b001101) //or immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'bz;
logicfn=2'b01;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b001110) //xor immediate
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b01;
alusrc=1'b1;
addsub=1'bz;
logicfn=2'b10;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b100011) //load word
begin
regwrite=1'b1;
regdst=2'b00;
reginsrc=2'b00;
alusrc=1'b1;
addsub=1'b0;
logicfn=1'bz;
fnclass=2'b10;
dataread=1'b1;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b100011) //store word
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'b1;
addsub=1'b0;
logicfn=1'bz;
fnclass=2'b10;
dataread=1'b0;
datawrite=1'b1;
brtype=2'b00;
pcsrc=2'b00;
end
if (op==6'b000010) //jump
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=1'bz;
pcsrc=2'b01;
end
if (op==6'b000001) //branch on less than 0
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b11;
pcsrc=2'b00;
end
if (op==6'b000100) //branch on equal
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b01;
pcsrc=2'b00;
end
if (op==6'b000101) //branch on not equal
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b10;
pcsrc=2'b00;
end
if (op==6'b000011) //jump and link
begin
regwrite=1'b1;
regdst=2'b10;
reginsrc=2'b10;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b01;
end
if ({op,fn}==12'b000000100000) //add
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b0;
logicfn=1'bz;
fnclass=2'b10;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000100010) //subtract
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b1;
logicfn=1'bz;
fnclass=2'b10;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000101010) //set less than
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b1;
logicfn=1'bz;
fnclass=2'b01;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000100100) //and
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b0;
logicfn=2'b00;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000100101) //or
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b0;
logicfn=2'b01;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000100110) //xor
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b0;
logicfn=2'b10;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000100111) //nor
begin
regwrite=1'b1;
regdst=2'b01;
reginsrc=2'b01;
alusrc=1'b0;
addsub=1'b0;
logicfn=2'b11;
fnclass=2'b11;
dataread=1'b0;
datawrite=1'b0;
brtype=2'b00;
pcsrc=2'b00;
end
if ({op,fn}==12'b000000001000) //jump register
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=1'bz;
pcsrc=2'b10;
end
if ({op,fn}==12'b000000001100) //system call
begin
regwrite=1'b0;
regdst=1'bz;
reginsrc=1'bz;
alusrc=1'bz;
addsub=1'bz;
logicfn=1'bz;
fnclass=1'bz;
dataread=1'b0;
datawrite=1'b0;
brtype=1'bz;
pcsrc=2'b11;
end
end
endmodule

Control Section Multi Cycle

module
exp9(clk,rst,op,lw,pc_write,inst_data,mem_read,mem_write,IR_write,reg_src,reg_wrt,alu_src_x,reg
_dst,pc_src,alu_src_y,alu_func,jump_add,jb_op);
input clk,rst,lw;
output reg pc_write,inst_data,mem_read,mem_write,IR_write,reg_src,reg_wrt,alu_src_x,jump_add;
input [1:0] op; //for state 1
input [2:0]jb_op; //for state 5
output reg [2:0] reg_dst,pc_src,alu_src_y;
output reg [4:0]alu_func;
parameter S0=4'b0000,
S1=4'b0001,
S2=4'b0010,
S3=4'b0011,
S4=4'b0100,
S5=4'b0101,
S6=4'b0110,
S7=4'b0111,
S8=4'b1000,
S9=4'b1001,
S10=4'b1010;
reg[3:0]state=S0;
always@(posedge clk)
begin
if(rst==0)
begin
case(state)
S0:begin //state 0
state<=S1;
inst_data<=0;
pc_write<=1;
pc_src<=2'b11;
alu_src_x<=0;
alu_src_y<=2'b00;
IR_write<=1;
mem_read<=1;
end
S1:begin //state 1
alu_src_x<=0;
alu_src_y<=2'b11;
alu_func<=5'b0xx10; //+
if(op==2'b00)//jump/br
state<=S5;
else if(op==2'b01)//lw/sw
state<=S2;
else if(op==2'b10)//alu
state<=S7;
end
S2:begin //state 2
alu_src_x<=1;
alu_src_y<=2'b10;
alu_func<=5'b0xx10;
if(lw==1)
state<=S3;
else if(lw==0)
state<=S6;
end
S3:begin //state 3
inst_data<=1;
mem_read<=1;
state<=S4;
end
S4:begin //state 4
reg_dst<=2'b00;
reg_src<=0;
reg_wrt<=1;
state<=S0;
end
S5:begin //state 5
alu_src_x<=1;
alu_src_y<=2'b01;
alu_func<=5'b1xx10;//-
if(jb_op==3'b000)//j inst
begin
jump_add<=0;
pc_src<=2'b00;
pc_write<=1;
end
else if(jb_op==3'b001)//jal
begin
jump_add<=0;
pc_src<=2'b00;
pc_write<=1;
reg_dst<=2'b10;
reg_src<=1;
reg_wrt<=1;
end
else if(jb_op==3'b010)//syscall
begin
jump_add<=1;
pc_src<=2'b00;
pc_write<=1;
end
else if(jb_op==3'b011)//jr
begin
jump_add<=1'bx;
pc_src<=2'b01;
pc_write<=1;
end
else if(jb_op==3'b100)//branch
begin
jump_add<=1'bx;
pc_src<=2'b10;
end
state<=S0;
end
S6:begin //state 6
inst_data<=1;
mem_write<=1;
state<=S0;
end
S7:begin //state 7
alu_src_x<=1;
alu_src_y<=2'b01;
alu_func<=5'bxxxxx;//
state<=S8;
end
S8:begin //state 8
reg_dst<=2'b01;
reg_src<=1;
reg_wrt<=1;
state<=S0;
end
endcase
end
else
state=S0;
end
endmodule

Next Addr

module Next_Add (CLK, rst, Rs, Rt, Pc, Jta, BrType, SysCallAdd, PcSrc, IncPc, NextPc);
    input CLK, rst;
    input [31:0] Pc, Rs, Rt;
    input [25:0] Jta;
    input [1:0] BrType, PcSrc;
    input [31:0] SysCallAdd;
    output reg [31:0] IncPc, NextPc;

    reg BrTrue;
    reg [29:0] Adder_in1;
    always @(posedge CLK) begin
        if (rst) begin
            IncPc = 32'b0;
            NextPc = 32'b0;
        end else begin
            case (BrType)
                2'b00: BrTrue = 1'b0; // No Branch
                2'b01: begin // BEQ
                    if (Rs == Rt) BrTrue = 1'b1; else BrTrue = 1'b0;
                end
                2'b10: begin // BNE
                    if (Rs != Rt) BrTrue = 1'b1; else BrTrue = 1'b0;
                end
                2'b11: begin // BLTZ
                    if (Rs[31] == 1) BrTrue = 1'b1; else BrTrue = 1'b0;
                end
            endcase

            if (BrTrue == 1'b1) begin
                if (Jta[15] == 1'b1)
                    Adder_in1 = {{14{1'b1}}, Jta[15:0]};
                else
                    Adder_in1 = {{14{1'b0}}, Jta[15:0]};
            end else
                Adder_in1 = 30'b0;

            IncPc = {(Adder_in1 + Pc[31:2] + 30'b1), 2'b00};
            case (PcSrc)
                2'b00: NextPc = IncPc;
                2'b01: NextPc = {IncPc[31:28], Jta, 2'b00};
                2'b10: NextPc = SysCallAdd;
                2'b11: NextPc = {Rs[31:2], 2'b00};
            endcase
        end
    end
endmodule